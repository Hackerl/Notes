计算机将信息按位编码，通常组织成字节序列
根据定义的变量类型，决定取几字节，以及如何解释二进制码表示的数值
所以，同一个串二进制码可被解读成不同数值，强制类型转换时，也只是转换解读方式

对于乘法实质上就是通过移位操作和加、减法组合而成
如：
     有符号整数 -3（101）*3（011）
     等价于 101*(010+001) = 101*010+101*001 = 101<<1+101<<0
     有符号整数移位后，111010+111101=110111=-9
     有符号整数一位要补符号位

     无符号整数 5（101）*3（011）
     等价于 101*(010+001) = 101*010+101*001 = 101<<1+101<<0
     无符号整数移位后，001010+000101=001111=15

总的来说，无符号与有符号乘法计算，只是移位操作不同

浮点数：
     V=(-1)^s * M * 2^E
     s为符号位，M为尾数，E为阶码
     单精度s、exp、frac字段分别是1位、8位、23位
     双精度为1位、11位、52位
     根据exp字段不同，分为规格化（exp不等于0、255）、非规格化（exp为全0）、无穷大（exp全1，f全零）、NaN（exp全1，f不为零）
     将exp转为E、f转为M的方式根据类型不同而不同
     规格化：E=e-Bias  Bias为偏置值，等于2^(k-1) - 1；M=1+f
     非规格化：E=1-Bias，M=f；当f为全零，表示浮点数0，s为1表示-0，s为0表示+0

栈：
     栈顶永远是地址最低的
     入栈：esp寄存器储存的指针地址减小，将数值存入
     出栈：数值被读取，esp指针增加，但数值不会消失，直至被后如栈的覆盖
     因为栈和程序代码以及其他形式的程序数据都放在同一储存器中，所有程序可用标准存储器寻址方式访问栈的任意位置

C、汇编：
     C定义的全局变量等信息储存在存储器的栈中，编译成汇编语言时，操作变量，需要从栈中读取变量
     局部变量一般储存在寄存器中，但并不会标识变量名，只是机器内部某种记忆
     BP为基址寄存器，一般在函数中用来保存进入函数时的sp的栈顶基址，便于读取相关变量

LEA:
     加载有效地址，将源操作数取起地址送到目的操作数
     lea (地址)  eax：（）为取出地址中的数值，该函数不会引用存储器，而是直接将地址送入eax
