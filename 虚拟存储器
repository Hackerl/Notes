虚拟存储器由许多虚拟页面构成
页面分为三类：
     未分配的：没有在磁盘上创建一块空间，并使该虚拟页面指向该空间，之后访问该虚拟地址，就知道数据储存在磁盘的哪个地方
     缓存的：该页面指向磁盘上一块空间，并且该空间已经缓存到了主存中，更新页表，可通过页表得到数据在主存上的位置
     未缓存的：页面指向磁盘上上一块空间，但是没有缓存该空间
虚拟地址翻译成物理地址，访问页表，查询虚拟地址对应处的条目，如果未缓存则触发缺页错误，缓存了就直接从主存中取数据

虚拟存储器与高速缓存结合：
     虚拟存储器将虚拟地址和物理地址映射，而高速缓存让通过物理地址取数据的过程更加迅速，两者并不冲突
     CPU发送虚拟地址到MMU，MMU生成PTE地址，并从高速缓存/主存请求得到页表中的相关条目
     如果不命中，需要将磁盘上的块缓存到主存中，然后重复步骤，得到相关条目，通过条目翻译得到物理地址
     将物理地址发送到高速缓存/主存，从最高层高速缓存L1开始查询，如果物理地址对应的块缓存在L1中，则立即取出
     如果不在L1中，则向下查询，并将数据层层往上缓存，直到找到数据块，并缓存在其上的每层高速缓存中，然后从L1中取出数据

磁盘以页面大小为块进行传输，高速缓存以特定块大小进行传输
那么依据大小不同，虚拟地址与物理地址划分也不同

首先看虚拟地址的划分：
     磁盘与主存间以页面大小传送数据，假设一个页面大小是2^n字节
     那么根据页表选定该页面的起始地址后，还需要2^n个偏移地址，才能取出每一个字节
     所以将低n为作为VPO，从页表中查询出前面的PPN，拼接成一个物理地址
     先不考虑高数缓存，在主存中寻址就是按照物理地址，所以只有后n位不同的虚拟地址在页表中的条目PPN是一样的
     后n位就可以作为偏移地址，共有2^n个不同的数，每个不同的数都表示一个不同的地址，这样便可以取出页中每一个字节
     这样也要求页面的划分4KB对齐，物理地址的低n为才能从0～2^n

再考虑高速缓存：
     既然已经弄懂了依据物理地址在主存上寻址，那么应用到高速缓存中也不难理解
     主存和高速缓存中间以块大小传送数据，假设块大小为2^m，那么与虚拟地址划分页面同理，物理地址后m为作为块偏移
     前n-m为作为缓存组引索，页面为一组连续的地址，从起始位置开始按块划分，可以划分成2^n/2^m=n-m块
     每一块中的前n-m不同，将会存放在不同的高速缓存组中，后m位作为块偏移，可以读取每一个字节

     此时还没有考虑从页表中取出的PPN，PPN是缓存标记，用来确定真正缓存了物理地址
     我们可以知道每个页面相同块将存放在同一组中，那么依据页面不同就可以确定缓存数据为哪一块
     页面正是由PPN所确定，可见PPN与缓存标记相对应
     这并不是巧合，恰恰是巧妙的涉及导致
     因为这种巧妙设计，CPU获得虚拟地址后，立即可以将VPO发送给高速缓存确定是否存在该缓存组
     根据VPN取回PPN后，PPN作为缓存标记确定缓存数据

全局变量：
     全局变量一般在C程序中已经定义完成，编译成可执行文件后，存在于.data节中
     加载器加载可执行文件时，将磁盘上的文件映射到虚拟空间数据段.data
     但实际上.data并未储存任何数据，实际数据还储存在磁盘上，当处理器试图取指令或则变量时
     CPU试图发送.text、.data上的虚拟地址，试图读取数据
     MMU通过查询页表，如果磁盘上的数据没有缓存到主存，那么触发缺页
     将数据缓存到主存后，再次查询页表，翻译成物理地址，从高速缓存/主存取出数据传回CPU

局部变量：
     局部变量一般不存在.data中，在运行时被栈管理
     由.text中的指令，直接将立即数推入栈中

动态存储器分配：
     有些时候，并不能确定数据的长度，如与用户交互是，使用scanf读取键盘输入
     这是需要在程序运行时，动态分配地址空间，存储数据，虚拟空间中的堆，正是为此而设计的
     malloc(size)请求堆分配给数据至少size字节的空间，实际上就是将堆映射到了主存上一片空间
     相当于映射到匿名文件（请求二进制零的页），将主存上该空间数据设为零，以储存数据
