unicode可以表示几乎所有字符
与ascii码类似，unicode下每个字符都有对应的整数

所有的编码方式都是基于unicode的，unicode给出了所有字符的对应关系，却没有明确储存方式
那么我们该如何将一串字符存储在内存中，你可以按照任意顺序存储，比如你就讲这些字符的unicode顺序储存在内存中
那么问题来了，你该如何解读，你如何知道哪几个字节组合在一起是一个字符，因为unicode的字符二进制长度是不一样的
所以随意的一串字符，可能每个字符对应的unicode二进制长度都不一样，系统无法知道每个字符的长度信息，所以无法解读

基于unicode，就有了一系列编码方式，它们都是为了储存unicode串而产生的
如UTF-8、GB2312，它们针对原始的unicode串，进行一个规则的转换，然后存储在主存中
当读取该已编码的字符串时，应该以对应的编码方式解读,讲该字符串转换为unicode串，此时根据规则可以得知哪几个字节表示一个字符
然后根据unicode的对应关系，输出正确的字符
简单来说，unicode定义了各个字符的名字，但是很多名字连在一起，并不知道如何切分
所以需要编码方式储存这些名字，将切分的信息隐藏在其中，然后以对应的方式解码，得到名字，根据unicode输出正确的字符

在python中，如果直接定义字符串，那么文字内容是以UTF-8编码储存在主存中的
调用print，会用系统的默认编码方式去解读该字符串，linux系统默认编码为UTF-8
所以此时，会用正确的UTF-8编码去解读该串二进制数

文件的传输都是建立在编码上的，windows默认编码是GB2312，所以其上的文字数据都是以GB2312存储
然而inux系统默认编码为UTF-8，所以直接打开会以UTF-8方式去解读，此时就会发生乱码
正确的方法是，以GB2312去解读，然后转换为UTF-8编码方式存储

另外需要注意，zip压缩文件如果压缩和解压时的编码不一样
那么解压出来的文字二进制串可能发生改变，此时用正确的编码去解读也无效
