链接是将各种代码和数据部分收集起来组合成一个单一文件的过程

静态链接：
     以一组可重定位目标文件和命令行参数作为输入，生成一个完全链接的可加载和运行的可执行目标文件
     比如你写了两个c程序文件，main.c与foo.c，在main.c中希望引用foo.c中定义的函数foo()，在foo.c中希望引用main.c定义的全局变量buf。
     分别将两个c文件进行预处理、编译、汇编：
         预处理阶段：预处理器（cpp）根据以字符#开头的命令，读取头文件内容，直接插入程序文本中，得到另一个c程序，通常以 .i 作为文件拓展名
         编译阶段：编译器（ccl）将文本文件 .i 翻译成文本文件 .s ，它包含一个汇编语言程序
         汇编阶段：汇编器（as）将 .s 翻译成机器语言指令，并打包成可重定位目标程序 .o，它是一个二进制文件，字节编码是机器语言指令
     经过三步，得到了main.o、foo.o，但是两者是分开处理的，main希望引用foo函数，但是没有得到任何关于foo.c的信息
     那么main.s（汇编语言）中的调用指令call foo如何处理？
     如果调用的函数在本地定义了，则可以确定foo的地址，而此时foo在另一文件中定义，所以汇编器（as）无法确定其地址
     此时，汇编器假设该符号是在其他模块中定义的，生成符号相关信息条目，并交给链接器处理

     想进一步了解链接器的工作，需要先了解一下可重定位目标文件的格式：
         可重定位目标文件由很多节组成，每个节都储存着特定的重要信息
         ELF头
         .text         //储存程序的机器代码
         .rodata    //只读数据，如printf语句中的格式串和开关语句的跳转表
         .data       //储存已初始化的全局C变量数值，如定义的数组、字符串，将储存在节中一串连续的地址中
         .bss        //未初始化的变量，程序中已声明，但是为赋值的
         .symtab  //可重定位目标文件的符号表，表明各符号在相应节中的偏移，比如数组buf储存在.data开始处，那么符号表中将记录这信息
         .rel.text  //存放重定位条目，汇编器遇到对最终位置未知的目标引用，将生成一个重定位条目，如mian中call foo，不清楚foo的具体位置
         .rel.data //已初始化数据的重定位条目
         .debyg
         .line
         .strtab
         节头部表
     每一个可重定向目标文件都有一个符号表，它包含了程序所定义和引用的符号信息
     在链接的上下文中，有三种不同的符号：
         1.由本模块定义能被其他模块引用的全局符号
         2.有其他模块定义并被本模块引用的全局符号，称为外部符号
         3.只能被本模块定义和引用的本地符号

     符号表由汇编器构造，存放在.symtab节中，符号表由若干个条目组成，每个条目储存这一个符号的信息：
         typedef struct{
              int name;
              int value;
              int size;
              char type:4,
                       binding:4;
              char reserved;
              char section;
              }Elf_Symbol;
         name是符号的名字
         value是符号的地址，对于可重定位模块来说，value是距离其所在节点起始位置的偏移，对于可执行目标，则是一个绝对地址
         type指定是数据还是函数，若是引用的外部符号，则暂时为NOTYPE
         binding表示符号是本地的还是全局的
         section表示与符号相关的节，该字段是一个到节头部表的引索

     每个符号都和本目标文件的某个节关联，符号表存放在.symtab中，而其中的符号与.data、.text等节点关联
     而有些特殊的符号，section字段为ABS代表不应该重定位的符号，UNDEF代表为定义的符号，COMMON表示还未被分配位置的未初始化的符号
     如main.o的符号表：
         Num:     Value     Size     Type     BInd     Ot     Ndx     Name
               8:             0          8  OBJECT GLOBAL 0          3       buf
               9:             0          17  FUNC   GLOBAL 0           1       main
              10:            0          0  NOTYPE GLOBAL 0      UND    foo
               11:            4           4 OBJECT  GLOBAL 0      COM    bufp 
     buf是本模块定义的全局变量，section字段为3，表示与.data字节相关
     因为是可重定位目标文件，所以value表示相对于关联节的偏移，buf是一个位于.data节中偏移为0处的8字节（size）目标，8字节储存着buf的数值
     main是一个位于.text节中偏移为0处的17字节（size）函数，17字节包含main函数的所有指令
     第10个条目是对外部符号foo的引用，section字段为UND，表示未定义
     最后一个条目bufp表示已声明，但未赋值的符号，在链接是当作一个.bss目标分配

     现在我们已经知道.symtab中的符号表，记录着符号信息的位置，如数组buf对应.data开始的8字节，函数main的第一条代码在.text偏移为0处
     此时还没有为数据段.data、代码段.text分配运行时的储存地址，以及代码中的符号引用的地址
     考虑main.c程序，main.o的.text中会有一条指令call mian，用来调用主函数，虽然符号表记录着main函数的全部指令在.text中的相对位置
     但call指令需要一个相对偏移，用下一指令的地址加上偏移就为main函数第一条指令的地址，但此时并没有为各节分配地址

     再考虑main函数中应该存在的代码call foo，该指令试图调用foo.c中的函数
     汇编器在生成符号表时，发现本模块没有定义，所以section字段为UND，那么二进制指令call后面的相对偏移更加无法确定

     现在需要解决的问题是：引入另外模块的符号，赋给各节储存器位置，计算call指令后的偏移值

     链接过程分为符号解析、重定位，两步完成将解决所有问题
     符号解析：将每个模块的引用与任意模块符号表中的一个确定的符号定义联系起来，如将main.c中foo的引用与foo.c中符号表条目foo联系起来
     重定位：
         重定位节和符号定义：
             将所有相同类型的节合并为同一类型的新的聚合节，然后链接器将运行时储存器的地址赋给新的聚合节，赋给输入模块定义的每个节
             以及赋给输入模块定义的每个符号；完成这一步后，程序中的每个指令和全局变量都有惟一的储存器地址了
         重定位节中的符号引用：
             链接器根据已有的储存器地址修改代码节和数据节中对每个符号的引用，使其指向正确的地址
     最常见的重定向条目为R_386_PC32、R_386_32
     R_386_PC32：当汇编器编译call指令时，会生成该重定位条目，希望链接器完成“重定位节和符号定义“后根据该条目修改call二进制指令中的偏移量
     R_386_32：当汇编器编译jxxx指令时，会生成该重定位条目，希望链接器完成“重定位节和符号定义“后根据该条目修改跳转指令后的绝对地址

     重定向条目：
         typedef struct{
              int offset;
              int symbol:24,
                    type:8;
              }Elf32_Rel
    
     offset指明需要修改的位置，该字段是相对于字符所在节的偏移
     symbol表明需要指向的符号，此时该符号已被赋给了储存器地址
     type指明重定位条目类型，包括R_386_PC32、R_386_32共有11种

     现在基本清楚了链接流程：
     1.汇编器编译为每个符号生成符号表，包括外部符号和本模块定义的符号
     2.遇到不确定位置的符号，则生成一个重定向条目，如main中call foo，则生成  7: R_386_PC32 foo，0是相对于节.text的偏移，即需要修改的位置
     3.链接器执行符号解析，将各目标模块之间的符号联系起来，如将main.o中引用的foo函数与foo.o符号表中定义的foo函数联系起来
     4.重定位节和符号定义，合并各模块节，并分配储存器地址
     5.重定位节中的符号引用，根据重定向条目，修改符号引用处的地址

     如下，是main.o的.text节中mian主函数调用foo函数的指令：
         6:  e8 fc ff ff ff                                  call   7<main+0x>
                                              重定向条目： 7: R_386_PC32 foo

     7表示需要修改的位置，.text偏移为7处，就是call指令（e8）后的相对偏移，一般的重定位条目该数都为0xfffffffc（十进制-4），原因会在重定位算法中解释
     R_386_PC32表示类型，重定位一个使用32位PC相对地址的引用
     foo表示应该指向的符号，完成重定位节和符号定义，各模块已聚合，各符号表已经联系起来，foo函数当然存在于符号表中，而且赋给了其地址

     所以完成该重定向只需根据foo的储存地址计算偏移量，然后覆盖.text节偏移量为7的地方
