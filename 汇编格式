;filename.asm
stack        segment                                     ;定义堆栈段stack
               ............                                      ;分配堆栈段的大小
stack        ends                                           ;堆栈段结束
data         segment                                      ;定义数据段data
               ............                                       ;定义数据
data         ends                                            ;数据段结束
code         segment  'code'                            ;定义代码段
               asuume cs:code,ds:data,ss:stack    ;确定CS/DS/SS指向的逻辑段
start:       mov ax,data                                  ;设置数据段的段地址DS
               mov ds,ax
               ..............                                      ;程序代码
               mov ax,4c00h                                ;返回DOS
               int 21h
code        ends                                              ;代码段结束
           ............                                            ;子程序代码
               end  start                                      ;汇编结束，程序起始点为start

如上，是一个完整的汇编程序格式
在我们写好的汇编程序中，已经人为设定了四个段地址——代码段、数据段、附加段、堆栈段
我们使用XX segment来定义一个段的起始，然后在段中输入数据
比如在代码段中就输入我们的主程序代码，数据段中就定义我们的全局变量
然而，现在的文本程序还没有经过编译器编译，编译需要生成一个可执行程序
该可执行程序已经分好了代码段、数据段、堆栈段、附加段，计算机执行程序时，加载各段到内存中
然后从可执行程序中记录的入口地址，开始执行第一条命令

那么，编译器如何编译文本代码
asuume的作用就是告诉编译器我们文本程序假设的段地址，因为只有编译器知道各段才能正确编译
编译器从asuume cs:code知道代码从code处开始，便可以顺着代码分析编译，比如讲第一句代码作为入口地址
mov ds,ax此句作用是讲数据段地址存入ds寄存器中，可能会有人认为assume定义过各段的含义了，为何多次一举

汇编程序中有一种命令叫伪指令，它并不做任何实际任务，它用来告诉编辑器如何进行编译
assume就属于伪指令，用来告诉编译器我们文本中假设的段地址，所以编译器才知道程序实际代码从code处开始
所以assume并没有实际对寄存器进行操作，ds、es、ss也没有数据
而cs却不同，因为执行可执行文件，加载完各段后，就需要执行第一条代码了，所以cs需要编译时就确定
编译完成后，cs以及入口ip都存在可执行文件中
相应的segment是定义段的伪指令，编译器编译时会根据此伪指令生成正确的段

编译器的编译过程相当微妙，通过伪指令的引导，生成正确可执行程序
